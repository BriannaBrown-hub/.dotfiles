"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const indexer_1 = require("@salesforce/lwc-language-server/lib/indexer");
const auraUtils = __importStar(require("../aura-utils"));
const fs = __importStar(require("fs-extra"));
const lightning_lsp_common_2 = require("@salesforce/lightning-lsp-common");
const line_column_1 = __importDefault(require("line-column"));
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const change_case_1 = __importDefault(require("change-case"));
const events_1 = __importDefault(require("events"));
const tagInfo_1 = require("@salesforce/lightning-lsp-common/lib/indexer/tagInfo");
const { WorkspaceType } = lightning_lsp_common_1.shared;
class AuraIndexer {
    constructor(context) {
        this.eventEmitter = new events_1.default();
        this.listeners = new Map();
        this.AURA_TAGS = new Map();
        this.AURA_EVENTS = new Map();
        this.AURA_NAMESPACES = new Set();
        this.context = context;
        this.context.addIndexingProvider({ name: 'aura', indexer: this });
    }
    async configureAndIndex() {
        const indexingTasks = [];
        this.lwcIndexer = new indexer_1.LWCIndexer(this.context, false);
        this.context.addIndexingProvider({ name: 'lwc', indexer: this.lwcIndexer });
        this.addListener('delete', (tag) => {
            const transformedName = this.transformLwcTagName(tag);
            const auraName = [transformedName.namespace, transformedName.name].join(':');
            this.deleteCustomTag(auraName);
        });
        this.addListener('set', (tagInfo) => {
            const tag = tagInfo.name;
            if (tagInfo.type === tagInfo_1.TagType.CUSTOM) {
                const interopTagInfo = this.transformLwcTagToAura(tag, tagInfo);
                this.setCustomTag(interopTagInfo);
            }
        });
        indexingTasks.push(this.lwcIndexer.configureAndIndex());
        indexingTasks.push(this.loadStandardComponents());
        indexingTasks.push(this.loadSystemTags());
        indexingTasks.push(this.indexCustomComponents());
        this.indexingTasks = Promise.all(indexingTasks).then(() => undefined);
        return this.indexingTasks;
    }
    async waitForIndexing() {
        return this.indexingTasks;
    }
    resetIndex() {
        this.eventEmitter.emit('clear');
        if (this.lwcIndexer) {
            this.lwcIndexer.eventEmitter.removeAllListeners();
            this.lwcIndexer.resetIndex();
        }
        this.AURA_TAGS.clear();
        this.AURA_EVENTS.clear();
    }
    getAuraTags() {
        return this.AURA_TAGS;
    }
    getAuraNamespaces() {
        return [...this.AURA_NAMESPACES];
    }
    getAuraByTag(tag) {
        return this.getAuraTags().get(tag);
    }
    clearTagsforDirectory(directory, sfdxProject) {
        const name = lightning_lsp_common_2.componentUtil.componentFromDirectory(directory, sfdxProject);
        this.deleteCustomTag(name);
    }
    async indexFile(file, sfdxProject) {
        if (!fs.existsSync(file)) {
            this.clearTagsforFile(file, sfdxProject);
            return;
        }
        const markup = await fs.readFile(file, 'utf-8');
        const result = lightning_lsp_common_2.parse(markup);
        const tags = [];
        for (const root of result.roots) {
            tags.push(...this.searchAura(root));
        }
        const tagInfo = this.getTagInfo(file, sfdxProject, markup, result.roots[0]);
        if (!tagInfo) {
            this.clearTagsforFile(file, sfdxProject);
            return;
        }
        if (!tagInfo.name) {
            console.warn(`File ${file} has malformed tagname, ignoring`);
            return;
        }
        const attributeInfos = tags
            .filter(tag => tag.tag.startsWith('aura:attribute'))
            .filter(node => (node.parent && (node.parent.tag === 'aura:application' || node.parent.tag === 'aura:component')) ||
            node.parent.tag === 'aura:event' ||
            node.parent.tag === 'aura:interface')
            .map(node => {
            const attributes = node.attributes || {};
            const documentation = this.trimQuotes(attributes.description);
            const jsName = this.trimQuotes(attributes.name);
            const type = this.trimQuotes(attributes.type);
            const startColumn = new line_column_1.default(markup).fromIndex(node.start);
            const endColumn = new line_column_1.default(markup).fromIndex(node.end - 1);
            const location = {
                uri: vscode_uri_1.default.file(file).toString(),
                range: {
                    start: {
                        line: startColumn.line,
                        character: startColumn.col,
                    },
                    end: {
                        line: endColumn.line,
                        character: endColumn.col,
                    },
                },
            };
            return new lightning_lsp_common_2.AttributeInfo(jsName, documentation, undefined, undefined, type, location);
        });
        tagInfo.attributes = attributeInfos;
        this.setCustomTag(tagInfo);
        return tagInfo;
    }
    addListener(event, listener) {
        this.listeners.set(event, listener);
        this.lwcIndexer.eventEmitter.on(event, listener);
    }
    removeListeners() {
        for (const [event, listener] of this.listeners.entries()) {
            this.lwcIndexer.eventEmitter.removeListener(event, listener);
        }
    }
    async indexCustomComponents() {
        const startTime = process.hrtime();
        const markupfiles = await this.context.findAllAuraMarkup();
        for (const file of markupfiles) {
            try {
                await this.indexFile(file, this.context.type === WorkspaceType.SFDX);
            }
            catch (e) {
                console.log(`Error parsing markup from ${file}:`, e);
            }
        }
        console.info(`Indexed ${markupfiles.length} files in ${lightning_lsp_common_1.utils.elapsedMillis(startTime)} ms`);
    }
    clearTagsforFile(file, sfdxProject) {
        const name = lightning_lsp_common_2.componentUtil.componentFromFile(file, sfdxProject);
        this.deleteCustomTag(name);
    }
    deleteCustomTag(tag) {
        this.AURA_TAGS.delete(tag);
        this.AURA_EVENTS.delete(tag);
        this.eventEmitter.emit('delete', tag);
    }
    setAuraNamespaceTag(namespace) {
        if (!this.AURA_NAMESPACES.has(namespace)) {
            this.AURA_NAMESPACES.add(namespace);
            this.eventEmitter.emit('set-namespace', namespace);
        }
    }
    setCustomEventTag(info) {
        this.setAuraNamespaceTag(info.namespace);
        this.AURA_EVENTS.set(info.name, info);
        this.eventEmitter.emit('set', info);
    }
    setCustomTag(info) {
        this.setAuraNamespaceTag(info.namespace);
        this.AURA_TAGS.set(info.name, info);
        this.eventEmitter.emit('set', info);
    }
    async loadSystemTags() {
        const data = await fs.readFile(auraUtils.getAuraSystemResourcePath(), 'utf-8');
        const auraSystem = JSON.parse(data);
        for (const tag in auraSystem) {
            // TODO need to account for LWC tags here
            if (auraSystem.hasOwnProperty(tag) && typeof tag === 'string') {
                const tagObj = auraSystem[tag];
                const info = new lightning_lsp_common_1.TagInfo(null, tagInfo_1.TagType.SYSTEM, false, []);
                if (tagObj.attributes) {
                    for (const a of tagObj.attributes) {
                        // TODO - could we use more in depth doc from component library here?
                        info.attributes.push(new lightning_lsp_common_2.AttributeInfo(a.name, a.description, undefined, undefined, a.type, undefined, 'Aura Attribute'));
                    }
                }
                info.documentation = tagObj.description;
                info.name = tag;
                info.namespace = tagObj.namespace;
                this.setCustomTag(info);
            }
        }
    }
    async loadStandardComponents() {
        const data = await fs.readFile(auraUtils.getAuraStandardResourcePath(), 'utf-8');
        const auraStandard = JSON.parse(data);
        for (const tag in auraStandard) {
            if (auraStandard.hasOwnProperty(tag) && typeof tag === 'string') {
                const tagObj = auraStandard[tag];
                const info = new lightning_lsp_common_1.TagInfo(null, tagInfo_1.TagType.STANDARD, false, []);
                if (tagObj.attributes) {
                    tagObj.attributes.sort((a, b) => {
                        return a.name.localeCompare(b.name);
                    });
                    for (const a of tagObj.attributes) {
                        // TODO - could we use more in depth doc from component library here?
                        info.attributes.push(new lightning_lsp_common_2.AttributeInfo(a.name, a.description, undefined, undefined, a.type, undefined, 'Aura Attribute'));
                    }
                }
                info.documentation = tagObj.description;
                info.name = tag;
                info.namespace = tagObj.namespace;
                // Update our in memory maps
                // TODO should we move interfaces/apps/etc to a separate map also?
                if (tagObj.type === 'event') {
                    this.setCustomEventTag(info);
                }
                else {
                    this.setCustomTag(info);
                }
            }
        }
    }
    searchAura(node) {
        const results = [];
        if (node.tag.indexOf(':') !== -1) {
            results.push(node);
        }
        for (const child of node.children) {
            results.push(...this.searchAura(child));
        }
        return results;
    }
    trimQuotes(str) {
        if (!str) {
            return '';
        }
        return str.replace(/"([^"]+(?="))"/g, '$1');
    }
    getTagInfo(file, sfdxProject, contents, node) {
        if (!node) {
            return;
        }
        const attributes = node.attributes || {};
        const documentation = this.trimQuotes(attributes.description);
        const startColumn = new line_column_1.default(contents).fromIndex(node.start);
        const endColumn = new line_column_1.default(contents).fromIndex(node.end - 1);
        const location = {
            uri: vscode_uri_1.default.file(file).toString(),
            range: {
                start: {
                    line: startColumn.line,
                    character: startColumn.col,
                },
                end: {
                    line: endColumn.line,
                    character: endColumn.col,
                },
            },
        };
        const name = lightning_lsp_common_2.componentUtil.componentFromFile(file, sfdxProject);
        const info = new lightning_lsp_common_1.TagInfo(file, tagInfo_1.TagType.CUSTOM, false, [], location, documentation, name, 'c');
        return info;
    }
    isAuraNamespace(namespace) {
        return this.AURA_NAMESPACES.has(namespace);
    }
    transformLwcTagName(tag) {
        const namespace = tag.split('-')[0];
        const name = tag
            .split('-')
            .slice(1)
            .join('-');
        return {
            namespace,
            name: change_case_1.default.camelCase(name),
        };
    }
    transformLwcTagToAura(tag, tagInfo) {
        const interopTagInfo = JSON.parse(JSON.stringify(tagInfo));
        const transformedName = this.transformLwcTagName(tag);
        interopTagInfo.name = [transformedName.namespace, transformedName.name].join(':');
        const attrs = [];
        for (const attribute of interopTagInfo.attributes) {
            const attrname = change_case_1.default.camelCase(attribute.jsName || attribute.name);
            attrs.push(new lightning_lsp_common_2.AttributeInfo(attrname, attribute.documentation, attribute.memberType, attribute.decorator, attribute.type, attribute.location, ''));
        }
        const info = new lightning_lsp_common_1.TagInfo(interopTagInfo.file, 
        // TagType[interopTagInfo.type as string],
        interopTagInfo.type, true, attrs, interopTagInfo.location, interopTagInfo.documentation, interopTagInfo.name, transformedName.namespace, interopTagInfo.properties, interopTagInfo.methods);
        return info;
    }
}
exports.default = AuraIndexer;
//# sourceMappingURL=indexer.js.map