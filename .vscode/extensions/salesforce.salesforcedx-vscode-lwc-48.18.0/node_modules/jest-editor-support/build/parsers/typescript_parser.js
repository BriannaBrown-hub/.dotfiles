"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _fs = require("fs");

var _typescript = _interopRequireDefault(require("typescript"));

var _parser_nodes = require("./parser_nodes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Note (2019/04/16):
 *
 * This is a direct port from the deprecated jest-test-typescript-parser in https://github.com/facebook/jest, as jest moving to babel-7, which includes direct typescript
 * support, the package is removed.
 *
 * However "jest-test-typescript-parser" is used by 3rd party tools such as vscode-jest, together with "jest-editor-support",
 * therefore, for the continuity and backward compatibility, we merged the legacy parser here and take responsibility in selecting the
 * proper parser for the given file. Therefore tools that adopt the new "jest-editor-support" package should remove
 * "jest-test-typescript-parser".
 *
 * 
 */

/* eslint-disable no-param-reassign */
function getNode(file, expression, node) {
  var start = file.getLineAndCharacterOfPosition(expression.getStart(file));
  node.start = {
    column: start.character + 1,
    line: start.line + 1
  };
  var pos = expression.getEnd();
  var end = file.getLineAndCharacterOfPosition(pos); // our end position is 1-based end character, including whitespace and
  // statement separator.  getLineAndCharacterOfPosition in typescript, however,
  // returns the 1-based location of the last non-whitespace char position.
  // Therefore we need to adjust for the actual lineEnd position here

  var lineEnd = file.getLineEndOfPosition(pos);
  var lineEndDiff = lineEnd - pos; // TypeScript parser is 0 based, so we have to increment by 1 to normalize
  // but the character position is the exclusive, so no need to to increment by 1

  node.end = {
    column: end.character + lineEndDiff,
    line: end.line + 1
  };
  node.file = file.fileName;
  return node;
} // eslint-disable-next-line import/prefer-default-export


function parse(file, data) {
  var sourceFile = _typescript.default.createSourceFile(file, data || (0, _fs.readFileSync)(file).toString(), _typescript.default.ScriptTarget.ES3);

  var parseResult = new _parser_nodes.ParseResult(file);

  var addNode = function addNode(tsNode, parent, type) {
    var child = parent.addChild(type);
    getNode(sourceFile, tsNode, child);

    if (child instanceof _parser_nodes.NamedBlock) {
      var arg = tsNode.arguments[0];
      child.name = arg.text;

      if (!child.name) {
        if (_typescript.default.isTemplateExpression(arg)) {
          child.name = sourceFile.text.substring(arg.pos + 1, arg.end - 1);
        }
      }

      if (child.name != null) {
        var start = sourceFile.getLineAndCharacterOfPosition(arg.pos);
        var end = sourceFile.getLineAndCharacterOfPosition(arg.end);
        child.nameRange = new _parser_nodes.ParsedRange(start.line + 1, start.character + 2, end.line + 1, end.character - 1);
      } else {
        // eslint-disable-next-line no-console
        console.warn("NamedBlock but no name found for ".concat(type, " tsNode="), tsNode);
      }

      parseResult.addNode(child);
    } else {
      // block has no name, thus perform extra dedup check by line info
      parseResult.addNode(child, true);
    }

    return child;
  };

  function searchNodes(parent) {
    var findText = function findText(expression) {
      return expression && expression.text ? expression.text : undefined;
    };

    return function (node) {
      var sNode;

      if (node.kind === _typescript.default.SyntaxKind.CallExpression) {
        var text = node.expression ? findText(node.expression) || findText(node.expression.expression) : undefined;

        if (text === 'describe') {
          sNode = addNode(node, parent, 'describe');
        } else if (text === 'it' || text === 'test' || text === 'fit') {
          sNode = addNode(node, parent, 'it');
        } else {
          var element = node.expression;
          var expectText = '';

          while (element && !expectText) {
            expectText = element.text;
            element = element.expression;
          }

          if (expectText === 'expect') {
            sNode = addNode(node, parent, 'expect');
          }
        }
      }

      _typescript.default.forEachChild(node, searchNodes(sNode || parent));
    };
  }

  _typescript.default.forEachChild(sourceFile, searchNodes(parseResult.root));

  return parseResult;
}