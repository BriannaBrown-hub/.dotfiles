"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path")); // is this ok?
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const utils_1 = require("@salesforce/lightning-lsp-common/lib/utils");
const deep_equal_1 = __importDefault(require("deep-equal"));
const { WorkspaceType } = lightning_lsp_common_1.shared;
async function onIndexCustomComponents(context, files) {
    // set paths for all current components in all the projects jsconfig.json files
    for (const modulesDir of await context.getModulesDirs()) {
        const paths = {};
        for (const file of files) {
            const tag = lightning_lsp_common_1.componentUtil.moduleFromFile(file, context.type === WorkspaceType.SFDX);
            // path must be relative to location of jsconfig.json
            const relativeFilePath = lightning_lsp_common_1.utils.relativePath(modulesDir, file);
            paths[tag] = [relativeFilePath];
        }
        // set "paths" in jsconfig.json
        const jsconfigFile = path.join(modulesDir, 'jsconfig.json');
        try {
            // note, this read/write file must be synchronous, so it is atomic
            const jsconfig = utils_1.readJsonSync(jsconfigFile);
            // deep clone of jsconfig created for update comparison
            const newJsconfig = JSON.parse(JSON.stringify(jsconfig));
            if (!jsconfig.compilerOptions ||
                !jsconfig.compilerOptions.hasOwnProperty('baseUrl') ||
                jsconfig.compilerOptions.baseUrl !== '.' ||
                !jsconfig.compilerOptions.hasOwnProperty('paths') ||
                JSON.stringify(jsconfig.compilerOptions.paths) !== JSON.stringify(paths)) {
                if (!jsconfig.compilerOptions) {
                    newJsconfig.compilerOptions = {};
                }
                newJsconfig.compilerOptions.baseUrl = '.';
                newJsconfig.compilerOptions.paths = paths;
                if (!deep_equal_1.default(jsconfig, newJsconfig)) {
                    utils_1.writeJsonSync(jsconfigFile, newJsconfig);
                }
            }
        }
        catch (err) {
            console.log(`onIndexCustomComponents(LOTS): Error reading jsconfig ${jsconfigFile}`, err);
        }
    }
}
exports.onIndexCustomComponents = onIndexCustomComponents;
async function onSetCustomComponent(context, file) {
    if (!file) {
        // could be a non-local tag, like LGC, etc
        return;
    }
    // add tag/path to component to all the project's jsconfig.json "paths"
    const moduleTag = lightning_lsp_common_1.componentUtil.moduleFromFile(file, context.type === WorkspaceType.SFDX);
    for (const modulesDir of await context.getModulesDirs()) {
        const relativeFilePath = lightning_lsp_common_1.utils.relativePath(modulesDir, file);
        const jsconfigFile = path.join(modulesDir, 'jsconfig.json');
        try {
            // note, this read/write file must be synchronous, so it is atomic
            const jsconfig = utils_1.readJsonSync(jsconfigFile);
            // deep clone of jsconfig created for update comparison
            const newJsconfig = JSON.parse(JSON.stringify(jsconfig));
            if (!jsconfig.compilerOptions) {
                newJsconfig.compilerOptions = {};
            }
            if (!jsconfig.compilerOptions.paths) {
                newJsconfig.compilerOptions.paths = {};
            }
            newJsconfig.compilerOptions.baseUrl = '.';
            newJsconfig.compilerOptions.paths[moduleTag] = [relativeFilePath];
            if (!deep_equal_1.default(jsconfig, newJsconfig)) {
                utils_1.writeJsonSync(jsconfigFile, newJsconfig);
            }
        }
        catch (err) {
            console.log(`onCreatedCustomComponent(${file}): Error reading jsconfig ${jsconfigFile}`, err);
        }
    }
}
exports.onSetCustomComponent = onSetCustomComponent;
async function onDeletedCustomComponent(moduleTag, context) {
    // delete tag from all the project's jsconfig.json "paths"
    for (const modulesDir of await context.getModulesDirs()) {
        const jsconfigFile = path.join(modulesDir, 'jsconfig.json');
        try {
            // note, this read/write file must be synchronous, so it is atomic
            const jsconfig = utils_1.readJsonSync(jsconfigFile);
            if (jsconfig.compilerOptions) {
                if (jsconfig.compilerOptions.paths) {
                    delete jsconfig.compilerOptions.paths[moduleTag];
                    utils_1.writeJsonSync(jsconfigFile, jsconfig);
                }
            }
        }
        catch (err) {
            console.log(`onDeletedCustomComponent${moduleTag}: Error reading jsconfig ${jsconfigFile}`, err);
        }
    }
}
exports.onDeletedCustomComponent = onDeletedCustomComponent;
//# sourceMappingURL=config.js.map