"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const vscode_languageserver_1 = require("vscode-languageserver");
const indexer_1 = require("./indexer");
const linter_1 = __importDefault(require("./template/linter"));
const compiler_1 = require("./javascript/compiler");
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const lightning_lsp_common_2 = require("@salesforce/lightning-lsp-common");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const custom_components_util_1 = require("./metadata-utils/custom-components-util");
const lwcTags_1 = require("./markup/lwcTags");
const decamelize_1 = __importDefault(require("decamelize"));
const { WorkspaceType } = lightning_lsp_common_1.shared;
// Create a standard connection and let the caller decide the strategy
// Available strategies: '--node-ipc', '--stdio' or '--socket={number}'
const connection = vscode_languageserver_1.createConnection();
lightning_lsp_common_1.interceptConsoleLogger(connection);
// Create a document namager supporting only full document sync
const documents = new vscode_languageserver_1.TextDocuments();
documents.listen(connection);
let htmlLS;
let context;
connection.onInitialize(async (params) => {
    const { workspaceFolders } = params;
    const workspaceRoots = [];
    for (const folder of workspaceFolders) {
        workspaceRoots.push(path.resolve(vscode_uri_1.default.parse(folder.uri).fsPath));
    }
    try {
        if (workspaceRoots.length === 0) {
            console.warn(`No workspace found`);
            return { capabilities: {} };
        }
        for (const root of workspaceRoots) {
            console.info(`Starting [[LWC]] language server at ${root}`);
        }
        const startTime = process.hrtime();
        context = new lightning_lsp_common_1.WorkspaceContext(workspaceRoots);
        context.configureProject();
        const lwcIndexer = new indexer_1.LWCIndexer(context);
        lwcIndexer.configureAndIndex();
        context.addIndexingProvider({ name: 'lwc', indexer: lwcIndexer });
        htmlLS = lightning_lsp_common_2.getLanguageService();
        htmlLS.addTagProvider(lwcTags_1.getLwcTagProvider());
        console.info('     ... language server started in ' + lightning_lsp_common_1.utils.elapsedMillis(startTime));
        return {
            capabilities: {
                textDocumentSync: documents.syncKind,
                completionProvider: {
                    resolveProvider: true,
                },
                hoverProvider: true,
                definitionProvider: true,
                workspace: {
                    workspaceFolders: {
                        supported: true,
                    },
                },
            },
        };
    }
    catch (e) {
        throw new Error(`LWC Language Server initialization unsuccessful. Error message: ${e.message}`);
    }
});
// Make sure to clear all the diagnostics when a document gets closed
documents.onDidClose(event => {
    connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
});
documents.onDidChangeContent(async (change) => {
    // TODO: when hovering on an html tag, this is called for the target .js document (bug in vscode?)
    const { document } = change;
    const { uri } = document;
    if (await context.isLWCTemplate(document)) {
        const diagnostics = linter_1.default(document);
        connection.sendDiagnostics({ uri, diagnostics });
    }
    else if (await context.isLWCJavascript(document)) {
        const { metadata, diagnostics } = await compiler_1.compileDocument(document);
        connection.sendDiagnostics({ uri, diagnostics });
        if (metadata) {
            // writeConfigs is set to false to avoid config updates on every keystroke.
            custom_components_util_1.addCustomTagFromResults(context, uri, metadata, context.type === WorkspaceType.SFDX, false);
        }
    }
});
documents.onDidSave(async (change) => {
    const { document } = change;
    const { uri } = document;
    if (await context.isLWCJavascript(document)) {
        const { metadata } = await compiler_1.compileDocument(document);
        if (metadata) {
            custom_components_util_1.addCustomTagFromResults(context, uri, metadata, context.type === WorkspaceType.SFDX);
        }
    }
});
connection.onCompletion(async (textDocumentPosition) => {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (!(await context.isLWCTemplate(document))) {
        return { isIncomplete: false, items: [] };
    }
    const htmlDocument = htmlLS.parseHTMLDocument(document);
    return htmlLS.doComplete(document, textDocumentPosition.position, htmlDocument, {
        isSfdxProject: context.type === WorkspaceType.SFDX,
        useAttributeValueQuotes: false,
    });
});
connection.onCompletionResolve((item) => {
    return item;
});
connection.onHover(async (textDocumentPosition) => {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (!(await context.isLWCTemplate(document))) {
        return null;
    }
    const htmlDocument = htmlLS.parseHTMLDocument(document);
    return htmlLS.doHover(document, textDocumentPosition.position, htmlDocument);
});
function findJavascriptProperty(valueProperty, textDocumentPosition) {
    // couldn't find it within the markup file, try looking for it as a javascript property
    const fsPath = vscode_uri_1.default.parse(textDocumentPosition.textDocument.uri).fsPath;
    const parsedPath = path.parse(fsPath);
    const componentName = decamelize_1.default(parsedPath.name, '-');
    const namespace = path.basename(path.dirname(parsedPath.dir));
    const tagInfo = custom_components_util_1.getLwcByTag(namespace + '-' + componentName);
    if (tagInfo) {
        for (const property of [...tagInfo.properties, ...tagInfo.methods]) {
            if (property.name === valueProperty) {
                return {
                    uri: vscode_uri_1.default.file(tagInfo.file).toString(),
                    range: {
                        start: {
                            character: property.loc.start.column,
                            line: property.loc.start.line - 1,
                        },
                        end: {
                            character: property.loc.end.column,
                            line: property.loc.end.line - 1,
                        },
                    },
                };
            }
        }
    }
    return null;
}
connection.onDefinition(async (textDocumentPosition) => {
    const document = documents.get(textDocumentPosition.textDocument.uri);
    if (!(await context.isLWCTemplate(document))) {
        return null;
    }
    const htmlDocument = htmlLS.parseHTMLDocument(document);
    let def = htmlLS.findDefinition(document, textDocumentPosition.position, htmlDocument);
    if (!def) {
        def = htmlLS.getPropertyBindingTemplateDeclaration(document, textDocumentPosition.position, htmlDocument);
        if (!def) {
            const valueProperty = htmlLS.getPropertyBindingValue(document, textDocumentPosition.position, htmlDocument);
            if (valueProperty) {
                def = findJavascriptProperty(valueProperty, textDocumentPosition);
            }
        }
    }
    return def;
});
// Listen on the connection
connection.listen();
connection.onDidChangeWatchedFiles(async (change) => {
    try {
        const indexer = context.getIndexingProvider('lwc');
        return indexer.handleWatchedFiles(context, change);
    }
    catch (e) {
        connection.sendNotification(vscode_languageserver_1.ShowMessageNotification.type, { type: vscode_languageserver_1.MessageType.Error, message: `Error re-indexing workspace: ${e.message}` });
    }
});
connection.onRequest('salesforce/listComponents', () => {
    const tags = custom_components_util_1.getLwcTags();
    return JSON.stringify([...tags]);
});
//# sourceMappingURL=server.js.map