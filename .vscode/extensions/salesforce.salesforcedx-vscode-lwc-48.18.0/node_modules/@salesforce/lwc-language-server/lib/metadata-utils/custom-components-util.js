"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const config_1 = require("../config");
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const compiler_1 = require("../javascript/compiler");
const lightning_lsp_common_2 = require("@salesforce/lightning-lsp-common");
const path_1 = require("path");
const events_1 = __importDefault(require("events"));
const utils_1 = require("@salesforce/lightning-lsp-common/lib/utils");
const tagInfo_1 = require("@salesforce/lightning-lsp-common/lib/indexer/tagInfo");
const { WorkspaceType } = lightning_lsp_common_2.shared;
const LWC_STANDARD = 'lwc-standard.json';
const RESOURCES_DIR = '../resources';
const LWC_TAGS = new Map();
exports.eventEmitter = new events_1.default();
function resetCustomComponents() {
    LWC_TAGS.clear();
    exports.eventEmitter.emit('clear');
}
exports.resetCustomComponents = resetCustomComponents;
async function removeCustomTag(context, tagName, moduleTag, writeConfigs) {
    LWC_TAGS.delete(tagName);
    if (writeConfigs) {
        await config_1.onDeletedCustomComponent(moduleTag, context);
    }
    exports.eventEmitter.emit('delete', tagName);
}
async function setCustomTag(context, info, writeConfigs) {
    LWC_TAGS.set(info.name, info);
    if (writeConfigs) {
        await config_1.onSetCustomComponent(context, info.file);
    }
    exports.eventEmitter.emit('set', info);
}
async function updateCustomComponentIndex(updatedFiles, context, writeConfigs = true) {
    const isSfdxProject = context.type === WorkspaceType.SFDX;
    for (const f of updatedFiles) {
        if (f.type === vscode_languageserver_1.FileChangeType.Deleted && lightning_lsp_common_2.utils.isLWCWatchedDirectory(context, f.uri)) {
            const tagName = lightning_lsp_common_2.componentUtil.tagFromDirectory(f.uri, isSfdxProject);
            const moduleTag = lightning_lsp_common_2.componentUtil.moduleFromDirectory(f.uri, isSfdxProject);
            await removeCustomTag(context, tagName, moduleTag, writeConfigs);
        }
        else {
            const dir = vscode_uri_1.default.file(path.dirname(utils_1.toResolvedPath(f.uri))).toString();
            if (lightning_lsp_common_2.utils.isLWCWatchedDirectory(context, dir)) {
                const file = vscode_uri_1.default.parse(f.uri).fsPath;
                if (lightning_lsp_common_2.componentUtil.isJSComponent(file)) {
                    if (f.type === vscode_languageserver_1.FileChangeType.Created) {
                        await addCustomTagFromFile(context, file, isSfdxProject, writeConfigs);
                    }
                    else if (f.type === vscode_languageserver_1.FileChangeType.Deleted) {
                        const tagName = lightning_lsp_common_2.componentUtil.tagFromFile(file, context.type === WorkspaceType.SFDX);
                        const moduleName = lightning_lsp_common_2.componentUtil.moduleFromFile(file, context.type === WorkspaceType.SFDX);
                        await removeCustomTag(context, tagName, moduleName, writeConfigs);
                    }
                }
            }
        }
    }
}
exports.updateCustomComponentIndex = updateCustomComponentIndex;
function getLwcTags() {
    return LWC_TAGS;
}
exports.getLwcTags = getLwcTags;
function getLwcByTag(tag) {
    return LWC_TAGS.get(tag);
}
exports.getLwcByTag = getLwcByTag;
function getlwcStandardResourcePath() {
    return path_1.join(__dirname, RESOURCES_DIR, LWC_STANDARD);
}
exports.getlwcStandardResourcePath = getlwcStandardResourcePath;
async function loadStandardComponents(context, writeConfigs = true) {
    const data = await fs.readFile(getlwcStandardResourcePath(), 'utf-8');
    const lwcStandard = JSON.parse(data);
    for (const tag in lwcStandard) {
        if (lwcStandard.hasOwnProperty(tag) && typeof tag === 'string') {
            const standardTag = lwcStandard[tag];
            const description = standardTag.description;
            const namespace = standardTag.namespace;
            let attributes = [];
            if (standardTag.attributes) {
                attributes = standardTag.attributes.map((attribute) => {
                    return new lightning_lsp_common_1.AttributeInfo(attribute.name, attribute.description, undefined, undefined, attribute.type, undefined, 'LWC standard attribute');
                });
            }
            const info = new lightning_lsp_common_1.TagInfo(null, tagInfo_1.TagType.STANDARD, true, attributes, undefined, description, tag, namespace);
            await setCustomTag(context, info, writeConfigs);
        }
    }
}
exports.loadStandardComponents = loadStandardComponents;
async function addCustomTag(context, tag, uri, metadata, writeConfigs) {
    const doc = metadata.doc;
    const attributes = compiler_1.extractAttributes(metadata, uri);
    const publicAttributes = attributes.publicAttributes;
    // declarationLoc may be undefined if live file doesn't extend LightningElement yet
    const range = metadata.declarationLoc ? compiler_1.toVSCodeRange(metadata.declarationLoc) : vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(0, 0), vscode_languageserver_1.Position.create(0, 0));
    const location = vscode_languageserver_1.Location.create(uri, range);
    const namespace = tag.split('-')[0];
    const file = utils_1.toResolvedPath(uri);
    const tagInfo = new lightning_lsp_common_1.TagInfo(file, tagInfo_1.TagType.CUSTOM, true, publicAttributes, location, doc, tag, namespace, compiler_1.getProperties(metadata), compiler_1.getMethods(metadata));
    await setCustomTag(context, tagInfo, writeConfigs);
}
async function indexCustomComponents(context, writeConfigs = true) {
    const files = await context.findAllModules();
    // writeConfigs is set to false to avoid updating config twice for the same tag.
    // loadCustomTagsFromFiles and onIndexCustomComponents lead to the same config updates.
    await loadCustomTagsFromFiles(context, files, context.type === WorkspaceType.SFDX, false);
    if (writeConfigs) {
        await config_1.onIndexCustomComponents(context, files);
    }
}
exports.indexCustomComponents = indexCustomComponents;
async function loadCustomTagsFromFiles(context, filePaths, sfdxProject, writeConfigs) {
    const startTime = process.hrtime();
    for (const file of filePaths) {
        await addCustomTagFromFile(context, file, sfdxProject, writeConfigs);
    }
    console.log('loadCustomTagsFromFiles: processed ' + filePaths.length + ' files in ' + lightning_lsp_common_2.utils.elapsedMillis(startTime));
}
async function addCustomTagFromResults(context, uri, metadata, sfdxProject, writeConfigs = true) {
    const tag = lightning_lsp_common_2.componentUtil.tagFromFile(vscode_uri_1.default.parse(uri).fsPath, sfdxProject);
    if (tag) {
        await addCustomTag(context, tag, uri, metadata, writeConfigs);
    }
}
exports.addCustomTagFromResults = addCustomTagFromResults;
async function addCustomTagFromFile(context, file, sfdxProject, writeConfigs = true) {
    const tag = lightning_lsp_common_2.componentUtil.tagFromFile(file, sfdxProject);
    if (tag) {
        // get attributes from compiler metadata
        try {
            const { metadata, diagnostics } = await compiler_1.compileFile(file);
            if (diagnostics.length > 0) {
                console.log('error compiling ' + file + ': ', diagnostics);
            }
            if (metadata) {
                const uri = vscode_uri_1.default.file(path.resolve(file)).toString();
                await addCustomTag(context, tag, uri, metadata, writeConfigs);
            }
        }
        catch (error) {
            console.log('error compiling ' + file, error);
        }
    }
}
exports.addCustomTagFromFile = addCustomTagFromFile;
//# sourceMappingURL=custom-components-util.js.map