"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const glob_1 = require("glob");
const fs = __importStar(require("fs-extra"));
const path_1 = require("path");
const xml2js_1 = require("xml2js");
const vscode_languageserver_1 = require("vscode-languageserver");
const util_1 = require("util");
const fs_extra_1 = require("fs-extra");
const glob = util_1.promisify(glob_1.Glob);
const CUSTOM_LABELS = new Set();
const CUSTOM_LABEL_FILES = new Set();
const CUSTOM_LABELS_DECLARATION_FILE = '.sfdx/typings/lwc/customlabels.d.ts';
function parseString(xml, options) {
    return new Promise((resolve, reject) => {
        if (options) {
            xml2js_1.parseString(xml, options, (err, results) => {
                if (err) {
                    reject(err);
                }
                resolve(results);
            });
        }
        else {
            xml2js_1.parseString(xml, (err, results) => {
                if (err) {
                    reject(err);
                }
                resolve(results);
            });
        }
    });
}
function resetCustomLabels() {
    CUSTOM_LABELS.clear();
    CUSTOM_LABEL_FILES.clear();
}
exports.resetCustomLabels = resetCustomLabels;
async function indexCustomLabels(context, writeConfigs = true) {
    const { workspaceRoots } = context;
    const { sfdxPackageDirsPattern } = await context.getSfdxProjectConfig();
    const CUSTOM_LABEL_GLOB_PATTERN = `${sfdxPackageDirsPattern}/**/labels/CustomLabels.labels-meta.xml`;
    try {
        const files = await glob(CUSTOM_LABEL_GLOB_PATTERN, { cwd: workspaceRoots[0] });
        for (const file of files) {
            CUSTOM_LABEL_FILES.add(path_1.join(workspaceRoots[0], file));
        }
        return processLabels(workspaceRoots[0], writeConfigs);
    }
    catch (err) {
        console.log(`Error queuing up indexing of labels. Error details:`, err);
        throw err;
    }
}
exports.indexCustomLabels = indexCustomLabels;
async function updateLabelsIndex(updatedFiles, { workspaceRoots }, writeConfigs = true) {
    let didChange = false;
    for (const f of updatedFiles) {
        if (f.uri.endsWith('CustomLabels.labels-meta.xml')) {
            didChange = true;
            if (f.type === vscode_languageserver_1.FileChangeType.Created) {
                CUSTOM_LABEL_FILES.add(vscode_languageserver_1.Files.uriToFilePath(f.uri));
            }
            else if (f.type === vscode_languageserver_1.FileChangeType.Deleted) {
                CUSTOM_LABEL_FILES.delete(vscode_languageserver_1.Files.uriToFilePath(f.uri));
            }
        }
    }
    if (didChange) {
        await processLabels(workspaceRoots[0], writeConfigs);
    }
}
exports.updateLabelsIndex = updateLabelsIndex;
async function processLabels(workspacePath, writeConfigs) {
    CUSTOM_LABELS.clear();
    if (writeConfigs) {
        const labelReadPromises = [];
        for (const filePath of CUSTOM_LABEL_FILES) {
            labelReadPromises.push(readLabelFile(filePath));
        }
        await Promise.all(labelReadPromises);
        if (CUSTOM_LABELS.size > 0) {
            return fs.writeFile(path_1.join(workspacePath, CUSTOM_LABELS_DECLARATION_FILE), generateLabelTypeDeclarations());
        }
    }
}
async function readLabelFile(filePath) {
    try {
        const data = await fs_extra_1.readFile(filePath, 'utf-8');
        const result = await parseString(data);
        for (const l of result.CustomLabels.labels) {
            if (l.fullName.length > 0) {
                CUSTOM_LABELS.add(l.fullName[0]);
            }
        }
    }
    catch (err) {
        console.log(`Error reading/parsing label file at ${filePath}. Error detatils:`, err);
    }
}
function generateLabelTypeDeclarations() {
    let resTypeDecs = '';
    const sortedCustomLabels = Array.from(CUSTOM_LABELS).sort();
    for (const res of sortedCustomLabels) {
        resTypeDecs += generateLabelTypeDeclaration(res);
    }
    return resTypeDecs;
}
function generateLabelTypeDeclaration(labelName) {
    const ns = 'c';
    const result = `declare module "@salesforce/label/${ns}.${labelName}" {
    var ${labelName}: string;
    export default ${labelName};
}
`;
    return result;
}
//# sourceMappingURL=custom-labels-util.js.map