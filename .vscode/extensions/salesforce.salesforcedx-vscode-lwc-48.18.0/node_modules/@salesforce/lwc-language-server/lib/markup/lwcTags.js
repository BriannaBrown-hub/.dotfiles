"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const custom_components_util_1 = require("../metadata-utils/custom-components-util");
// import { ClassMember } from '@lwc/babel-plugin-component';
const LWC_DIRECTIVE = 'LWC directive';
const LWC_DIRECTIVES = [
    new lightning_lsp_common_1.AttributeInfo('for:each', 'Renders the element or template block multiple times based on the expression value.', undefined, lightning_lsp_common_1.Decorator.API, 'expression binding', undefined, LWC_DIRECTIVE),
    new lightning_lsp_common_1.AttributeInfo('for:item', 'Bind the current iteration item to an identifier.', undefined, lightning_lsp_common_1.Decorator.API, 'expression binding', undefined, LWC_DIRECTIVE),
    new lightning_lsp_common_1.AttributeInfo('for:index', 'Bind the current iteration index to an identifier.', undefined, lightning_lsp_common_1.Decorator.API, 'expression binding', undefined, LWC_DIRECTIVE),
    new lightning_lsp_common_1.AttributeInfo('if:true', 'Renders the element or template if the expression value is thruthy.', undefined, lightning_lsp_common_1.Decorator.API, 'expression binding', undefined, LWC_DIRECTIVE),
    new lightning_lsp_common_1.AttributeInfo('if:false', 'Renders the element or template if the expression value is falsy.', undefined, lightning_lsp_common_1.Decorator.API, 'expression binding', undefined, LWC_DIRECTIVE),
];
function getDirectiveInfo(label) {
    for (const info of LWC_DIRECTIVES) {
        if (label === info.name) {
            return info;
        }
    }
    return null;
}
exports.getDirectiveInfo = getDirectiveInfo;
function getLwcCompletionParticipant() {
    return {
        onHtmlAttributeValue: (context) => {
            return;
        },
        onHtmlContent: (context) => {
            return;
        },
    };
}
exports.getLwcCompletionParticipant = getLwcCompletionParticipant;
function getLwcTagProvider() {
    function addTags(collector) {
        for (const [tag, tagInfo] of custom_components_util_1.getLwcTags()) {
            collector(tag, tagInfo.name, tagInfo);
        }
    }
    function addAttributes(tag, collector) {
        const cTag = custom_components_util_1.getLwcByTag(tag);
        if (cTag) {
            for (const info of cTag.attributes) {
                collector(info.name, info, '');
            }
        }
    }
    function addExpressions(templateTag, collector) {
        const cTag = custom_components_util_1.getLwcByTag(templateTag);
        if (cTag) {
            cTag.properties.forEach(metadata => {
                collector(metadata.name, null, null);
            });
            cTag.methods.forEach(metadata => {
                collector(metadata.name, null, null);
            });
        }
    }
    function addDirectives(collector) {
        LWC_DIRECTIVES.map(info => {
            collector(info.name, info, null);
        });
    }
    return {
        getId: () => 'lwc',
        isApplicable: languageId => languageId === 'html',
        collectTags: (collector) => {
            addTags(collector);
        },
        collectAttributes: (tag, collector) => {
            addDirectives(collector);
            if (tag) {
                addAttributes(tag, collector);
            }
        },
        collectValues: ( /*tag: string, attribute: string, collector: (value: string) => void*/) => {
            // TODO provide suggestions by consulting shapeService
        },
        // TODO move this to ICompletionParticipant
        collectExpressionValues: (templateTag, collector) => {
            addExpressions(templateTag, collector);
        },
        getTagInfo: (tag) => custom_components_util_1.getLwcByTag(tag),
        getGlobalAttributes: () => LWC_DIRECTIVES,
    };
}
exports.getLwcTagProvider = getLwcTagProvider;
//# sourceMappingURL=lwcTags.js.map