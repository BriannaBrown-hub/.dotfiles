"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./base");
const path_1 = require("path");
const registry_1 = require("../../utils/registry");
const errors_1 = require("../../errors");
const fs_1 = require("fs");
const fileSystemHandler_1 = require("../../utils/fileSystemHandler");
const path_2 = require("../../utils/path");
/**
 * Handles types with mixed content. Mixed content means there are one or more source
 * file(s) associated with a component with any file extension. Even an entire folder
 * can be considered "the content".
 *
 * __Example Types__:
 *
 * StaticResources, Documents, Bundle Types
 *
 * __Example Structures__:
 *
 *```text
 * foos/
 * ├── myFoo/
 * |   ├── fooFolder/
 * |      ├── foofighters.x
 * |   ├── foo.y
 * |   ├── fooBar.z
 * ├── myFoo.ext-meta.xml
 * bars/
 * ├── myBar.xyz
 * ├── myBar.ext2-meta.xml
 *```
 */
class MixedContent extends base_1.BaseSourceAdapter {
    getMetadataXmlPath(pathToSource) {
        return MixedContent.findXmlFromContentPath(pathToSource, this.type);
    }
    getSourcePaths(fsPath, isMetaXml) {
        let contentPath;
        const ignore = new Set();
        if (!isMetaXml) {
            contentPath = this.getPathToContent(fsPath);
            ignore.add(this.getMetadataXmlPath(fsPath));
        }
        else {
            const metadataXml = registry_1.parseMetadataXml(fsPath);
            contentPath = registry_1.findMetadataContent(path_1.dirname(fsPath), metadataXml.fullName);
            ignore.add(fsPath);
        }
        if (!fs_1.existsSync(contentPath)) {
            throw new errors_1.ExpectedSourceFilesError(this.type, fsPath);
        }
        const sources = fileSystemHandler_1.isDirectory(contentPath)
            ? fileSystemHandler_1.walk(contentPath, ignore)
            : [contentPath];
        return sources.filter(s => this.forceIgnore.accepts(s));
    }
    getPathToContent(source) {
        const pathParts = source.split(path_1.sep);
        const typeFolderIndex = pathParts.findIndex(part => part === this.type.directoryName);
        const offset = this.type.inFolder ? 3 : 2;
        return pathParts.slice(0, typeFolderIndex + offset).join(path_1.sep);
    }
    /**
     * A utility for finding a component's root metadata xml from a path to a component's
     * content. "Content" can either be a single file or an entire directory. If the content
     * is a directory, the path can be files or other directories inside of it.
     * @param source
     */
    static findXmlFromContentPath(contentPath, type) {
        const pathParts = contentPath.split(path_1.sep);
        const typeFolderIndex = pathParts.findIndex(part => part === type.directoryName);
        const offset = type.inFolder ? 3 : 2;
        const rootContentPath = pathParts
            .slice(0, typeFolderIndex + offset)
            .join(path_1.sep);
        const rootTypeDirectory = path_1.dirname(rootContentPath);
        const contentFullName = path_2.baseName(rootContentPath);
        return registry_1.findMetadataXml(rootTypeDirectory, contentFullName);
    }
}
exports.MixedContent = MixedContent;
//# sourceMappingURL=mixedContent.js.map