"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const registry_1 = require("../../utils/registry");
const path_1 = require("path");
const registryData = require("../data/registry.json");
const errors_1 = require("../../errors");
const path_2 = require("../../utils/path");
const forceIgnore_1 = require("../forceIgnore");
/**
 * The default source adapter.
 *
 * Direct usage of this adapter is for simple types with no additional content.
 * Unless there's a particular reason not to, other adapters will extend this one.
 * It handles shared functionality amongst the other adapters.
 *
 * __Example Types__:
 *
 * Layouts, PermissionSets, FlexiPages
 *
 * __Example Structure__:
 * ```text
 * foos/
 * ├── foo.ext-meta.xml
 * ├── bar.ext-meta.xml
 *```
 */
class BaseSourceAdapter {
    constructor(type, registry = registryData, forceIgnore = new forceIgnore_1.ForceIgnore()) {
        this.type = type;
        this.registry = registry;
        this.forceIgnore = forceIgnore;
    }
    /**
     * At the time of writing, Typescript does not have a `final` keyword so
     * nothing is stopping you from overriding this method. It's best if you don't
     * because this handles shared functionality across adapters. If you must,
     * create a new implementation of `SourceAdapter`.
     *
     * @param fsPath File path for a piece of metadata
     */
    getComponent(fsPath) {
        let metaXmlPath = fsPath;
        let isMetaXml = true;
        let parsedMetaXml = registry_1.parseMetadataXml(fsPath);
        // If the path is not a metadata xml, or the metadata xml is not in the root
        // of the type directory, defer fetching the file to the child adapter
        const rootTypePath = path_1.dirname(this.type.inFolder ? path_1.dirname(fsPath) : fsPath);
        const inRootTypeFolder = path_1.basename(rootTypePath) === this.type.directoryName;
        const requireStrictParent = !!this.registry.mixedContent[this.type.directoryName];
        if (!parsedMetaXml || (requireStrictParent && !inRootTypeFolder)) {
            metaXmlPath = this.getMetadataXmlPath(fsPath);
            if (!metaXmlPath) {
                throw new errors_1.RegistryError('error_missing_metadata_xml', [
                    fsPath,
                    this.type.name
                ]);
            }
            parsedMetaXml = registry_1.parseMetadataXml(metaXmlPath);
            isMetaXml = false;
        }
        if (this.forceIgnore.denies(metaXmlPath)) {
            throw new errors_1.UnexpectedForceIgnore('error_no_metadata_xml_ignore', [
                metaXmlPath,
                fsPath
            ]);
        }
        const component = {
            fullName: parsedMetaXml.fullName,
            type: this.type,
            xml: metaXmlPath,
            sources: this.getSourcePaths(fsPath, isMetaXml)
        };
        if (this.type.inFolder) {
            component.fullName = `${path_2.parentName(component.xml)}/${component.fullName}`;
        }
        return component;
    }
    /**
     * Override this method to tell the adapter how to locate a component's
     * root metadata xml file.
     *
     * @param pathToSource Path to a non root metadata xml file
     */
    getMetadataXmlPath(pathToSource // eslint-disable-line @typescript-eslint/no-unused-vars
    ) {
        return undefined;
    }
    /**
     * Override this method to tell the adapter how to locate a component's
     * source files.
     *
     * @param fsPath File path to base the inference of other source files
     * @param isMetaXml Whether or not the provided file path is a root metadata xml file
     */
    getSourcePaths(fsPath, // eslint-disable-line @typescript-eslint/no-unused-vars
    isMetaXml // eslint-disable-line @typescript-eslint/no-unused-vars
    ) {
        return [];
    }
}
exports.BaseSourceAdapter = BaseSourceAdapter;
//# sourceMappingURL=base.js.map