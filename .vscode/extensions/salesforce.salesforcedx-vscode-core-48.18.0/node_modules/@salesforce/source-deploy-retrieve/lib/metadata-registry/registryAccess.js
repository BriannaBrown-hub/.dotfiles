"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const adapters_1 = require("./adapters");
const registry_1 = require("../utils/registry");
const errors_1 = require("../errors");
const _1 = require(".");
const mixedContent_1 = require("./adapters/mixedContent");
const path_2 = require("../utils/path");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
const forceIgnore_1 = require("./forceIgnore");
/**
 * Infer information about metadata types and components based on source paths.
 */
class RegistryAccess {
    /**
     * @param data Optional custom registry data.
     */
    constructor(data) {
        this.data = data
            ? // deep freeze a copy, not the original object
                registry_1.deepFreeze(JSON.parse(JSON.stringify(data)))
            : // registryData is already frozen
                _1.registryData;
    }
    /**
     * Get metadata type information.
     *
     * @param name Name of the metadata type
     */
    getTypeFromName(name) {
        const lower = name.toLowerCase().replace(/ /g, '');
        if (!this.data.types[lower]) {
            throw new errors_1.TypeInferenceError('error_missing_type_definition', lower);
        }
        return this.data.types[lower];
    }
    /**
     * Get the metadata component(s) from a file path.
     *
     * @param fsPath File path for a piece of metadata
     */
    getComponentsFromPath(fsPath) {
        if (!fs_1.existsSync(fsPath)) {
            throw new errors_1.TypeInferenceError('error_path_not_found', fsPath);
        }
        let pathForFetch = fsPath;
        this.forceIgnore = forceIgnore_1.ForceIgnore.findAndCreate(fsPath);
        if (fileSystemHandler_1.isDirectory(fsPath)) {
            // If we can determine a type from a directory path, and the end part of the path isn't
            // the directoryName of the type itself, we know the path is part of a mixedContent component
            const typeId = this.determineTypeId(fsPath);
            if (typeId) {
                const type = this.getTypeFromName(typeId);
                const { directoryName, inFolder } = type;
                const parts = fsPath.split(path_1.sep);
                const folderOffset = inFolder ? 2 : 1;
                if (parts[parts.length - folderOffset] !== directoryName) {
                    pathForFetch =
                        mixedContent_1.MixedContent.findXmlFromContentPath(fsPath, type) || fsPath;
                }
            }
            if (pathForFetch === fsPath) {
                return this.getComponentsFromPathRecursive(fsPath);
            }
        }
        const component = this.fetchComponent(pathForFetch);
        return component ? [component] : [];
    }
    determineTypeId(fsPath) {
        let typeId;
        // attempt 1 - check if the file is part of a mixed content type
        const pathParts = new Set(fsPath.split(path_1.sep));
        for (const directoryName of Object.keys(this.data.mixedContent)) {
            if (pathParts.has(directoryName)) {
                typeId = this.data.mixedContent[directoryName];
                // types with folders only have folder components living at the top level.
                // if the fsPath is a folder component, let a future strategy deal with it
                const isFolderType = this.getTypeFromName(typeId).inFolder;
                if (isFolderType && path_2.parentName(fsPath) === directoryName) {
                    typeId = undefined;
                }
                break;
            }
        }
        // attempt 2 - check if it's a metadata xml file
        if (!typeId) {
            const parsedMetaXml = registry_1.parseMetadataXml(fsPath);
            if (parsedMetaXml) {
                typeId = this.data.suffixes[parsedMetaXml.suffix];
            }
        }
        // attempt 3 - try treating the file extension name as a suffix
        if (!typeId) {
            typeId = this.data.suffixes[path_2.extName(fsPath)];
        }
        return typeId;
    }
    fetchComponent(fsPath) {
        if (registry_1.parseMetadataXml(fsPath) && this.forceIgnore.denies(fsPath)) {
            // don't bother fetching the component if the meta xml is denied
            return;
        }
        const typeId = this.determineTypeId(fsPath);
        if (typeId) {
            const adapterId = this.data.adapters[typeId];
            const adapter = adapters_1.getAdapter(this.getTypeFromName(typeId), adapterId, this.forceIgnore);
            return adapter.getComponent(fsPath);
        }
        throw new errors_1.TypeInferenceError('error_could_not_infer_type', fsPath);
    }
    getComponentsFromPathRecursive(directory) {
        const dirQueue = [];
        const components = [];
        if (this.forceIgnore.denies(directory)) {
            return components;
        }
        for (const file of fs_1.readdirSync(directory)) {
            const path = path_1.join(directory, file);
            if (fileSystemHandler_1.isDirectory(path)) {
                dirQueue.push(path);
            }
            else if (registry_1.parseMetadataXml(path)) {
                const component = this.fetchComponent(path);
                if (component) {
                    components.push(component);
                    // don't traverse further if not in a root type directory. performance optimization
                    // for mixed content types and ensures we don't add duplicates of the component.
                    const isMixedContent = !!this.data.mixedContent[component.type.directoryName];
                    const typeDir = path_1.basename(path_1.dirname(component.type.inFolder ? path_1.dirname(path) : path));
                    if (isMixedContent && typeDir !== component.type.directoryName) {
                        return components;
                    }
                }
            }
        }
        for (const dir of dirQueue) {
            components.push(...this.getComponentsFromPathRecursive(dir));
        }
        return components;
    }
    getApiVersion() {
        return this.data.apiVersion;
    }
}
exports.RegistryAccess = RegistryAccess;
//# sourceMappingURL=registryAccess.js.map