"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
//@ts-ignore
const gitignore = require("gitignore-parser");
const path_1 = require("path");
const fs_1 = require("fs");
const constants_1 = require("../utils/constants");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
class ForceIgnore {
    constructor(forceIgnorePath = '') {
        try {
            const forceIgnoreContents = this.parseContents(fs_1.readFileSync(forceIgnorePath, 'utf8'));
            this.parser = gitignore.compile(forceIgnoreContents);
            this.forceIgnoreDirectory = path_1.dirname(forceIgnorePath);
        }
        catch (e) {
            // log no force ignore
        }
    }
    /**
     * Performs an upward directory search for a `.forceignore` file and returns a
     * `ForceIgnore` object based on the result. If there is no `.forceignore` file,
     * the returned `ForceIgnore` object will accept everything.
     *
     * @param seed Path to begin the `.forceignore` search from
     */
    static findAndCreate(seed) {
        let potentialForceIgnorePath = '';
        const projectConfigPath = fileSystemHandler_1.searchUp(seed, constants_1.FORCE_IGNORE_FILE);
        if (projectConfigPath) {
            potentialForceIgnorePath = path_1.join(path_1.dirname(projectConfigPath), constants_1.FORCE_IGNORE_FILE);
        }
        return new ForceIgnore(potentialForceIgnorePath);
    }
    denies(fsPath) {
        let denies = false;
        if (this.parser) {
            denies = this.parser.denies(path_1.relative(this.forceIgnoreDirectory, fsPath));
        }
        return denies || !this.isValidAgainstDefaults(fsPath);
    }
    accepts(fsPath) {
        let accepts = true;
        if (this.parser) {
            accepts = this.parser.accepts(path_1.relative(this.forceIgnoreDirectory, fsPath));
        }
        return accepts && this.isValidAgainstDefaults(fsPath);
    }
    /**
     * This is not how we should ultimately test a path against default ignores.
     * TODO: When we utilize a new matching module this should be replaced.
     */
    isValidAgainstDefaults(fsPath) {
        const name = path_1.basename(fsPath);
        return (!name.startsWith('.') &&
            !name.endsWith('.dup') &&
            name !== 'package2-descriptor.json' &&
            name !== 'package2-manifest.json');
    }
    parseContents(contents) {
        return contents
            .split('\n')
            .map(line => line.trim())
            .map(line => line.replace(/[\\\/]/g, path_1.sep))
            .map(line => line.replace(/^\\/, ''))
            .join('\n');
    }
}
exports.ForceIgnore = ForceIgnore;
//# sourceMappingURL=forceIgnore.js.map