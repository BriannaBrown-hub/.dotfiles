"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../metadata-registry/index");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
class ManifestGenerator {
    constructor() {
        this.xmlDef = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n';
        this.packageModuleStart = '<Package xmlns="http://soap.sforce.com/2006/04/metadata">\n';
        this.packageModuleEnd = '</Package>\n';
        this.registryAccess = new index_1.RegistryAccess();
    }
    createManifestFromPath(sourcePath, outputPath) {
        try {
            const mdComponents = this.registryAccess.getComponentsFromPath(sourcePath);
            const manifestMap = new Map().set(outputPath, this.createManifest(mdComponents));
            utils_1.createFiles(manifestMap);
        }
        catch (err) {
            throw new errors_1.RegistryError('error_on_manifest_creation', [sourcePath, err]);
        }
    }
    createManifest(components, apiVersion = this.registryAccess.getApiVersion()) {
        let output = this.xmlDef.concat(this.packageModuleStart);
        const metadataMap = this.createMetadataMap(components);
        for (const metadataType of metadataMap.keys()) {
            output = output.concat('\t<types>\n');
            for (const metadataName of metadataMap.get(metadataType)) {
                output = output.concat(`\t\t<members>${metadataName}</members>\n`);
            }
            output = output.concat(`\t\t<name>${metadataType}</name>\n`);
            output = output.concat('\t</types>\n');
        }
        output = output.concat(`\t<version>${apiVersion}</version>\n`, this.packageModuleEnd);
        return output;
    }
    createMetadataMap(components) {
        const metadataMap = new Map();
        for (const component of components) {
            const metadataType = this.registryAccess.getTypeFromName(component.type.name).name;
            const metadataName = component.fullName;
            if (metadataMap.has(metadataType)) {
                const metadataNames = metadataMap.get(metadataType);
                metadataNames.add(metadataName);
                metadataMap.set(metadataType, metadataNames);
            }
            else {
                const metadataNames = new Set();
                metadataNames.add(metadataName);
                metadataMap.set(metadataType, metadataNames);
            }
        }
        return metadataMap;
    }
}
exports.ManifestGenerator = ManifestGenerator;
//# sourceMappingURL=manifestGenerator.js.map