"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const fs_1 = require("fs");
const base_1 = require("./base");
const errors_1 = require("../../errors");
const path_1 = require("../../utils/path");
/**
 * Handles types with a single content file with a matching file extension.
 * These tend to be the programmatic types.
 *
 * __Example Types__:
 *
 * ApexClass, ApexTrigger, ApexComponent
 *
 * __Example Structure__:
 *
 * ```text
 * foos/
 * ├── foobar.ext
 * ├── foobar.ext-meta.xml
 *```
 */
class MatchingContentFile extends base_1.BaseSourceAdapter {
    getMetadataXmlPath(pathToSource) {
        return `${pathToSource}${utils_1.META_XML_SUFFIX}`;
    }
    getSourcePaths(fsPath, isMetaXml) {
        let sourcePath;
        if (isMetaXml) {
            const path = fsPath.slice(0, fsPath.lastIndexOf(utils_1.META_XML_SUFFIX));
            if (fs_1.existsSync(path)) {
                sourcePath = path;
            }
        }
        else if (this.registry.suffixes[path_1.extName(fsPath)]) {
            sourcePath = fsPath;
        }
        if (!sourcePath) {
            throw new errors_1.ExpectedSourceFilesError(this.type, fsPath);
        }
        else if (this.forceIgnore.denies(sourcePath)) {
            throw new errors_1.UnexpectedForceIgnore('error_no_source_ignore', [
                this.type.name,
                sourcePath
            ]);
        }
        return [sourcePath];
    }
}
exports.MatchingContentFile = MatchingContentFile;
//# sourceMappingURL=matchingContentFile.js.map