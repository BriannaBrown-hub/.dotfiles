"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const types_1 = require("../../types");
const errors_1 = require("../../errors");
// tslint:disable-next-line:no-var-requires
const DOMParser = require('xmldom-sfdx-encoding').DOMParser;
class BaseDeploy {
    constructor(connection) {
        this.connection = connection;
    }
    buildMetadataField(metadataContent) {
        try {
            const parser = new DOMParser();
            const document = parser.parseFromString(metadataContent, 'text/xml');
            const apiVersion = document.getElementsByTagName('apiVersion')[0]
                .textContent;
            const statusNode = document.getElementsByTagName('status')[0];
            const packageNode = document.getElementsByTagName('packageVersions')[0];
            const descriptionNode = document.getElementsByTagName('description')[0];
            const labelNode = document.getElementsByTagName('label')[0];
            const metadataField = Object.assign({ apiVersion }, (statusNode ? { status: statusNode.textContent } : {}), (packageNode ? { packageVersions: packageNode.textContent } : {}), (descriptionNode
                ? { description: descriptionNode.textContent }
                : {}), (labelNode ? { label: labelNode.textContent } : {}));
            return metadataField;
        }
        catch (e) {
            throw new errors_1.DeployError('error_parsing_metadata_file');
        }
    }
    toolingCreate(type, record) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.connection.tooling.create(type, record));
        });
    }
    // If bundle already exists then use Id and update existing
    // else, create a new bundle
    upsertBundle(Id) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataContent = fs_1.readFileSync(this.component.xml, 'utf8');
            const metadataField = this.buildMetadataField(metadataContent);
            let bundleResult;
            if (Id) {
                const bundleObject = { Id, Metadata: metadataField };
                bundleResult = (yield this.connection.tooling.update(this.component.type.name, bundleObject));
            }
            else {
                const bundleObject = {
                    FullName: this.component.fullName,
                    Metadata: metadataField
                };
                bundleResult = yield this.toolingCreate(this.component.type.name, bundleObject);
            }
            if (!bundleResult.success) {
                throw new errors_1.DeployError('error_creating_metadata_type', this.component.type.name);
            }
            return bundleResult;
        });
    }
    formatBundleOutput(deployResults, failure) {
        let toolingDeployResult;
        if (failure) {
            toolingDeployResult = {
                State: types_1.DeployStatusEnum.Failed,
                ErrorMsg: deployResults[0].problem,
                DeployDetails: {
                    componentSuccesses: [],
                    componentFailures: deployResults
                },
                isDeleted: false,
                metadataFile: this.component.xml
            };
        }
        else {
            toolingDeployResult = {
                State: types_1.DeployStatusEnum.Completed,
                DeployDetails: {
                    componentSuccesses: deployResults,
                    componentFailures: []
                },
                isDeleted: false,
                outboundFiles: this.component.sources,
                ErrorMsg: null,
                metadataFile: this.component.xml
            };
        }
        return toolingDeployResult;
    }
    createDeployResult(filepath, success, created, problem) {
        const formattedPaths = this.getFormattedPaths(filepath);
        const result = {
            success,
            deleted: false,
            fileName: filepath,
            fullName: formattedPaths[1],
            componentType: this.component.type.name
        };
        if (success) {
            result['created'] = created;
            result['changed'] = !created;
        }
        else {
            result['problem'] = problem;
            result['changed'] = false;
            result['created'] = false;
        }
        return result;
    }
    getFormattedPaths(filepath) {
        const pathParts = filepath.split(path_1.sep);
        const typeFolderIndex = pathParts.findIndex(part => part === this.component.type.directoryName);
        return [
            pathParts.slice(typeFolderIndex).join(path_1.sep),
            pathParts.slice(typeFolderIndex + 1).join(path_1.sep)
        ];
    }
}
exports.BaseDeploy = BaseDeploy;
//# sourceMappingURL=baseDeploy.js.map