"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs_1 = require("fs");
const utils_1 = require("../../utils");
const toolingApi_1 = require("../toolingApi");
const baseDeploy_1 = require("./baseDeploy");
class LwcDeploy extends baseDeploy_1.BaseDeploy {
    deploy(component) {
        return __awaiter(this, void 0, void 0, function* () {
            this.component = component;
            const lightningResources = yield this.buildResourceList();
            try {
                const results = yield this.upsert(lightningResources);
                return this.formatBundleOutput(results);
            }
            catch (e) {
                const failures = [
                    this.parseLwcError(e.message, lightningResources[0].FilePath)
                ];
                return this.formatBundleOutput(failures, true);
            }
        });
    }
    buildResourceList() {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceFiles = this.component.sources;
            sourceFiles.push(this.component.xml);
            const lightningResources = [];
            const existingResources = yield this.findLightningResources();
            const lightningBundle = existingResources[0]
                ? yield this.upsertBundle(existingResources[0].LightningComponentBundleId)
                : yield this.upsertBundle();
            const bundleId = lightningBundle.id;
            sourceFiles.forEach((sourceFile) => __awaiter(this, void 0, void 0, function* () {
                const source = fs_1.readFileSync(sourceFile, 'utf8');
                const format = utils_1.extName(sourceFile);
                let match;
                if (existingResources.length > 0) {
                    match = existingResources.find(resource => sourceFile.includes(resource.FilePath));
                }
                // If resource exists in org, assign the matching Id
                // else, assign the id of the bundle it's associated with
                const lightningResource = Object.assign({ FilePath: sourceFile, Source: source, Format: format }, (match ? { Id: match.Id } : { LightningComponentBundleId: bundleId }));
                // This is to ensure that the base file is deployed first for lwc
                // otherwise there is a `no base file found` error
                lightningResource.Format === 'js'
                    ? lightningResources.unshift(lightningResource)
                    : lightningResources.push(lightningResource);
            }));
            return lightningResources;
        });
    }
    upsert(lightningResources) {
        return __awaiter(this, void 0, void 0, function* () {
            const type = this.component.type.name;
            const successes = [];
            for (const resource of lightningResources) {
                if (resource.Id) {
                    const formattedDef = {
                        Source: resource.Source,
                        Id: resource.Id
                    };
                    yield this.connection.tooling.update(toolingApi_1.deployTypes.get(type), formattedDef);
                    successes.push(this.createDeployResult(resource.FilePath, true, false));
                }
                else {
                    const formattedDef = {
                        LightningComponentBundleId: resource.LightningComponentBundleId,
                        Format: resource.Format,
                        Source: resource.Source,
                        FilePath: this.getFormattedPaths(resource.FilePath)[0]
                    };
                    yield this.toolingCreate(toolingApi_1.deployTypes.get(type), formattedDef);
                    successes.push(this.createDeployResult(resource.FilePath, true, true));
                }
            }
            return successes;
        });
    }
    findLightningResources() {
        return __awaiter(this, void 0, void 0, function* () {
            const lightningResourceResult = yield this.connection.tooling.query(`Select LightningComponentBundleId, Id, Format, Source, FilePath from LightningComponentResource where LightningComponentBundle.DeveloperName = '${this.component.fullName}'`);
            return lightningResourceResult.records;
        });
    }
    parseLwcError(error, defaultPath) {
        try {
            const pathParts = error.split(/[\s\n\t]+/);
            const msgStartIndex = pathParts.findIndex(part => part.includes(':'));
            const fileObject = pathParts[msgStartIndex];
            const fileName = fileObject.slice(0, fileObject.indexOf(':'));
            const errLocation = fileObject.slice(fileObject.indexOf(':') + 1);
            const errorMessage = pathParts.slice(msgStartIndex + 2).join(' ');
            const file = this.component.sources.find(s => s.includes(fileName));
            const errObj = Object.assign({}, (errLocation
                ? { lineNumber: Number(errLocation.split(',')[0]) }
                : {}), (errLocation
                ? { columnNumber: Number(errLocation.split(',')[1]) }
                : {}), { problem: errorMessage, fileName: file, fullName: this.getFormattedPaths(file)[1], componentType: this.component.type.name, success: false, changed: false, created: false, deleted: false });
            return errObj;
        }
        catch (e) {
            //log error with parsing error message
            const errObj = {
                problem: error,
                fileName: defaultPath,
                fullName: this.getFormattedPaths(defaultPath)[1],
                componentType: this.component.type.name,
                success: false,
                changed: false,
                created: false,
                deleted: false
            };
            return errObj;
        }
    }
}
exports.LwcDeploy = LwcDeploy;
//# sourceMappingURL=lwcDeploy.js.map