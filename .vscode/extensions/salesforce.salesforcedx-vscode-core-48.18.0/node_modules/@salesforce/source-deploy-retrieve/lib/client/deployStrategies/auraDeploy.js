"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs_1 = require("fs");
const utils_1 = require("../../utils");
const toolingApi_1 = require("../toolingApi");
const baseDeploy_1 = require("./baseDeploy");
const index_1 = require("./index");
class AuraDeploy extends baseDeploy_1.BaseDeploy {
    deploy(component) {
        return __awaiter(this, void 0, void 0, function* () {
            this.component = component;
            const auraDefinitions = yield this.buildDefList();
            try {
                const promiseArray = auraDefinitions.map((def) => __awaiter(this, void 0, void 0, function* () { return this.upsert(def); }));
                const results = yield Promise.all(promiseArray);
                return this.formatBundleOutput(results);
            }
            catch (e) {
                const failures = [
                    this.parseAuraError(e.message, auraDefinitions[0].FilePath)
                ];
                return this.formatBundleOutput(failures, true);
            }
        });
    }
    buildDefList() {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceFiles = this.component.sources;
            const auraDefinitions = [];
            const existingDefinitions = yield this.findAuraDefinitions();
            const auraBundle = existingDefinitions[0]
                ? yield this.upsertBundle(existingDefinitions[0].AuraDefinitionBundleId)
                : yield this.upsertBundle();
            const bundleId = auraBundle.id;
            sourceFiles.forEach((sourceFile) => __awaiter(this, void 0, void 0, function* () {
                const source = fs_1.readFileSync(sourceFile, 'utf8');
                const suffix = utils_1.extName(sourceFile);
                const defType = this.getAuraDefType(sourceFile, suffix);
                const format = this.getAuraFormat(suffix);
                let match;
                if (existingDefinitions.length > 0) {
                    match = existingDefinitions.find(definition => definition.DefType === defType);
                }
                // If definition exists in org, assign the matching Id
                // else, assign the id of the bundle it's associated with
                const auraDef = Object.assign({ FilePath: sourceFile, DefType: defType, Source: source, Format: format }, (match ? { Id: match.Id } : { AuraDefinitionBundleId: bundleId }));
                // This is to ensure we return the correct project path when reporting errors
                // must be the file associated with the specified aura type
                index_1.AURA_TYPES.includes(auraDef.DefType)
                    ? auraDefinitions.unshift(auraDef)
                    : auraDefinitions.push(auraDef);
            }));
            return auraDefinitions;
        });
    }
    upsert(auraDef) {
        return __awaiter(this, void 0, void 0, function* () {
            const type = this.component.type.name;
            if (auraDef.Id) {
                const formattedDef = {
                    Source: auraDef.Source,
                    Id: auraDef.Id
                };
                yield this.connection.tooling.update(toolingApi_1.deployTypes.get(type), formattedDef);
                return this.createDeployResult(auraDef.FilePath, true, false);
            }
            else {
                const formattedDef = {
                    AuraDefinitionBundleId: auraDef.AuraDefinitionBundleId,
                    DefType: auraDef.DefType,
                    Format: auraDef.Format,
                    Source: auraDef.Source
                };
                yield this.toolingCreate(toolingApi_1.deployTypes.get(type), formattedDef);
                return this.createDeployResult(auraDef.FilePath, true, true);
            }
        });
    }
    getAuraFormat(suffix) {
        switch (suffix) {
            case 'js':
                return 'JS';
            case 'css':
                return 'CSS';
            case 'svg':
                return 'SVG';
            default:
                return 'XML';
        }
    }
    getAuraDefType(sourcePath, suffix) {
        const fileName = utils_1.baseName(sourcePath);
        switch (suffix) {
            case 'app':
                return 'APPLICATION';
            case 'cmp':
                return 'COMPONENT';
            case 'auradoc':
                return 'DOCUMENTATION';
            case 'css':
                return 'STYLE';
            case 'evt':
                return 'EVENT';
            case 'design':
                return 'DESIGN';
            case 'svg':
                return 'SVG';
            case 'js':
                if (fileName.endsWith('Controller')) {
                    return 'CONTROLLER';
                }
                else if (fileName.endsWith('Helper')) {
                    return 'HELPER';
                }
                else if (fileName.endsWith('Renderer')) {
                    return 'RENDERER';
                }
                break;
            case 'tokens':
                return 'TOKENS';
            case 'intf':
                return 'INTERFACE';
            default:
                return '';
        }
    }
    findAuraDefinitions() {
        return __awaiter(this, void 0, void 0, function* () {
            const auraDefResult = yield this.connection.tooling.query(`Select AuraDefinitionBundleId, Id, Format, Source, DefType from AuraDefinition where AuraDefinitionBundle.DeveloperName = '${this.component.fullName}'`);
            return auraDefResult.records;
        });
    }
    parseAuraError(error, defaultPath) {
        try {
            const errLocation = error.slice(error.lastIndexOf('[') + 1, error.lastIndexOf(']'));
            const errorParts = error.split(' ');
            const fileType = errorParts.find(part => {
                part = part.toLowerCase();
                return (part.includes('controller') ||
                    part.includes('renderer') ||
                    part.includes('helper'));
            });
            let fileName;
            if (fileType) {
                fileName = this.component.sources.find(s => s.toLowerCase().includes(fileType.toLowerCase()));
            }
            else {
                fileName = defaultPath;
            }
            const errObj = Object.assign({}, (errLocation
                ? { lineNumber: Number(errLocation.split(',')[0]) }
                : {}), (errLocation
                ? { columnNumber: Number(errLocation.split(',')[1]) }
                : {}), { problem: error, fileName: fileName, fullName: this.getFormattedPaths(fileName)[1], componentType: this.component.type.name, success: false, changed: false, created: false, deleted: false });
            return errObj;
        }
        catch (e) {
            // log error with parsing error message
            const errObj = {
                problem: error,
                fileName: defaultPath,
                fullName: this.getFormattedPaths(defaultPath)[1],
                componentType: this.component.type.name,
                success: false,
                changed: false,
                created: false,
                deleted: false
            };
            return errObj;
        }
    }
}
exports.AuraDeploy = AuraDeploy;
//# sourceMappingURL=auraDeploy.js.map