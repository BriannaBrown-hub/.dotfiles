"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const deployStrategies_1 = require("./deployStrategies");
const errors_1 = require("../errors");
const types_1 = require("../types");
const i18n_1 = require("../i18n");
const retrieveUtil_1 = require("./retrieveUtil");
const utils_1 = require("../utils");
const retrieveTypes = new Set([
    'ApexClass',
    'ApexTrigger',
    'ApexPage',
    'ApexComponent',
    'AuraDefinitionBundle',
    'LightningComponentBundle'
]);
exports.deployTypes = new Map([
    ['ApexClass', 'ApexClassMember'],
    ['ApexTrigger', 'ApexTriggerMember'],
    ['ApexPage', 'ApexPageMember'],
    ['ApexComponent', 'ApexComponentMember'],
    ['AuraDefinitionBundle', 'AuraDefinition'],
    ['LightningComponentBundle', 'LightningComponentResource']
]);
class ToolingApi extends types_1.BaseApi {
    retrieveWithPaths(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const retrievePaths = options.paths[0];
            return yield this.retrieve({
                output: options.output,
                components: this.registry.getComponentsFromPath(retrievePaths)
            });
        });
    }
    retrieve(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let retrieveResult;
            if (options.components.length > 1) {
                const retrieveError = new Error();
                retrieveError.message = i18n_1.nls.localize('tapi_retrieve_component_limit_error');
                retrieveError.name = 'MetadataRetrieveLimit';
                throw retrieveError;
            }
            const mdComponent = options.components[0];
            if (!retrieveTypes.has(mdComponent.type.name)) {
                const retrieveError = new Error();
                retrieveError.message = i18n_1.nls.localize('beta_tapi_membertype_unsupported_error', mdComponent.type.name);
                retrieveError.name = 'MetadataTypeUnsupported';
                throw retrieveError;
            }
            try {
                const queryResult = (yield this.connection.tooling.query(retrieveUtil_1.buildQuery(mdComponent)));
                if (queryResult && queryResult.records.length === 0) {
                    return {
                        success: true,
                        components: [],
                        message: i18n_1.nls.localize('error_md_not_present_in_org', mdComponent.fullName)
                    };
                }
                const saveFilesMap = retrieveUtil_1.queryToFileMap(queryResult, mdComponent, options.output);
                utils_1.createFiles(saveFilesMap);
                retrieveResult = {
                    success: true,
                    components: [mdComponent]
                };
            }
            catch (err) {
                throw new Error(i18n_1.nls.localize('error_in_tooling_retrieve', err));
            }
            return retrieveResult;
        });
    }
    deploy(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.components.length > 1) {
                const deployError = new errors_1.SourceClientError('tapi_deploy_component_limit_error');
                throw deployError;
            }
            const mdComponent = options.components[0];
            const metadataType = mdComponent.type.name;
            if (!exports.deployTypes.get(metadataType)) {
                throw new errors_1.SourceClientError('beta_tapi_membertype_unsupported_error', metadataType);
            }
            const deployStrategy = deployStrategies_1.getDeployStrategy(metadataType, this.connection);
            return deployStrategy.deploy(mdComponent);
        });
    }
    deployWithPaths(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const deployPaths = options.paths[0];
            return yield this.deploy({
                components: this.registry.getComponentsFromPath(deployPaths)
            });
        });
    }
}
exports.ToolingApi = ToolingApi;
//# sourceMappingURL=toolingApi.js.map