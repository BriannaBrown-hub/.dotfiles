"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const toolingApi_1 = require("../toolingApi");
const errors_1 = require("../../errors");
const types_1 = require("../../types");
const path_1 = require("../../utils/path");
const index_1 = require("./index");
const baseDeploy_1 = require("./baseDeploy");
class ContainerDeploy extends baseDeploy_1.BaseDeploy {
    deploy(component) {
        return __awaiter(this, void 0, void 0, function* () {
            this.component = component;
            const sourcePath = component.sources[0];
            const metadataPath = component.xml;
            const container = yield this.createMetadataContainer();
            yield this.createContainerMember([sourcePath, metadataPath], container);
            const asyncRequest = yield this.createContainerAsyncRequest(container);
            const output = yield this.toolingStatusCheck(asyncRequest);
            return output;
        });
    }
    createMetadataContainer() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataContainer = yield this.toolingCreate(index_1.METADATA_CONTAINER, {
                Name: `Deploy_MDC_${Date.now()}`
            });
            if (!metadataContainer.success) {
                throw new errors_1.DeployError('beta_tapi_mdcontainer_error');
            }
            return metadataContainer;
        });
    }
    createContainerMember(outboundFiles, container) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = container.id;
            const metadataContent = fs_1.readFileSync(outboundFiles[1], 'utf8');
            const metadataField = this.buildMetadataField(metadataContent);
            const body = fs_1.readFileSync(outboundFiles[0], 'utf8');
            const fileName = path_1.baseName(outboundFiles[0]);
            const contentEntity = yield this.getContentEntity(this.component.type.name, fileName);
            const containerMemberObject = Object.assign({ MetadataContainerId: id, FullName: fileName, Body: body, Metadata: metadataField }, (contentEntity ? { contentEntityId: contentEntity.Id } : {}));
            const containerMember = yield this.toolingCreate(toolingApi_1.deployTypes.get(this.component.type.name), containerMemberObject);
            if (!containerMember.success) {
                throw new errors_1.DeployError('beta_tapi_membertype_error', this.component.type.name);
            }
            return containerMember;
        });
    }
    getContentEntity(metadataType, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.connection.tooling
                .sobject(metadataType)
                .find({ Name: fileName }))[0];
        });
    }
    createContainerAsyncRequest(container) {
        return __awaiter(this, void 0, void 0, function* () {
            const contAsyncRequest = yield this.toolingCreate(index_1.CONTAINER_ASYNC_REQUEST, {
                MetadataContainerId: container.id
            });
            if (!contAsyncRequest.success) {
                throw new errors_1.DeployError('beta_tapi_car_error');
            }
            return contAsyncRequest;
        });
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    toolingStatusCheck(asyncRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            let retrieveResult = yield this.toolingRetrieve(index_1.CONTAINER_ASYNC_REQUEST, asyncRequest.id);
            let count = 0;
            while (retrieveResult.State === types_1.DeployStatusEnum.Queued && count <= 30) {
                yield this.sleep(100);
                retrieveResult = yield this.toolingRetrieve(index_1.CONTAINER_ASYNC_REQUEST, asyncRequest.id);
                count++;
            }
            retrieveResult.metadataFile = this.component.xml;
            return retrieveResult;
        });
    }
    toolingRetrieve(type, id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.connection.tooling.retrieve(type, id));
        });
    }
}
exports.ContainerDeploy = ContainerDeploy;
//# sourceMappingURL=containerDeploy.js.map